{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./resources/ui/canvas/Style.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;CCjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,K","file":"resources_ui_canvas_Style.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./resources/ui/canvas/Style.js\");\n","\"use strict\";\n// import * as PIXI from 'pixi.js';\n// import chroma from 'chroma-js';\n// import { ZoomBlurFilter } from 'pixi-filters';\n// import { colorToFill, borderPositionToAlignment, getAbsPoint, getCompiledBorderThickness, getBlendMode } from './utils';\n// interface RenderShapePathPointOptions {\n//   currentPoint: srm.CurvePoint;\n//   nextPoint: srm.CurvePoint;\n//   graphic: PIXI.Graphics;\n// }\n// export const renderShapePathPoint = ({ currentPoint, nextPoint, graphic }: RenderShapePathPointOptions) => {\n//   if (currentPoint.pointType === 'Straight') {\n//     if (nextPoint.pointType === 'Straight') {\n//       graphic.lineTo(nextPoint.point.x, nextPoint.point.y);\n//     } else {\n//       graphic.quadraticCurveTo(nextPoint.curveTo.x, nextPoint.curveTo.y, nextPoint.point.x, nextPoint.point.y);\n//     }\n//   } else {\n//     if (nextPoint.pointType === 'Straight') {\n//       graphic.quadraticCurveTo(currentPoint.curveFrom.x, currentPoint.curveFrom.y, nextPoint.point.x, nextPoint.point.y);\n//     } else {\n//       graphic.bezierCurveTo(currentPoint.curveFrom.x, currentPoint.curveFrom.y, nextPoint.curveTo.x, nextPoint.curveTo.y, nextPoint.point.x, nextPoint.point.y);\n//     }\n//   }\n// }\n// interface RenderShapePathShapeOptions {\n//   layer: srm.ShapePath | srm.ShapePartialHole;\n//   graphic: PIXI.Graphics;\n//   move?: {x: number, y: number};\n// }\n// export const renderShapePathShape = ({ layer, graphic, move }: RenderShapePathShapeOptions): Promise<PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     const { frame, points, closed } = layer;\n//     points.forEach((curvePoint: srm.CurvePoint, index: number) => {\n//       const currentPoint = getAbsPoint(curvePoint, frame, move);\n//       const onFirstPoint = index === 0;\n//       const onLastPoint = index === points.length - 1;\n//       if (onFirstPoint) {\n//         graphic.moveTo(currentPoint.point.x, currentPoint.point.y);\n//       }\n//       if (!onLastPoint) {\n//         const nextPoint = getAbsPoint(points[index + 1], frame, move);\n//         renderShapePathPoint({\n//           currentPoint: currentPoint,\n//           nextPoint: nextPoint,\n//           graphic: graphic\n//         });\n//       }\n//       if (onLastPoint && closed) {\n//         const firstPoint = getAbsPoint(points[0], frame, move);\n//         renderShapePathPoint({\n//           currentPoint: currentPoint,\n//           nextPoint: firstPoint,\n//           graphic: graphic\n//         });\n//         graphic.closePath();\n//       }\n//     });\n//     resolve(graphic);\n//   });\n// }\n// interface RenderShapePartialHolesOptions {\n//   layer: srm.ShapePartial;\n//   graphic: PIXI.Graphics;\n// }\n// export const renderShapePartialHoles = ({ layer, graphic }: RenderShapePartialHolesOptions) => {\n//   return new Promise((resolve, reject) => {\n//     const { holes } = layer;\n//     if (holes.length > 0) {\n//       const promises: Promise<any>[] = [];\n//       holes.forEach((hole: srm.ShapePath) => {\n//         promises.push(renderShapePathShape({\n//           graphic: graphic,\n//           layer: hole,\n//           move: {\n//             x: hole.frame.x - layer.frame.x,\n//             y: hole.frame.y - layer.frame.y\n//           }\n//         }));\n//       });\n//       Promise.all(promises).then(() => {\n//         resolve();\n//       });\n//     } else {\n//       resolve();\n//     }\n//   });\n// };\n// interface RenderShapePartialShapeOptions {\n//   layer: srm.ShapePartial;\n//   graphic: PIXI.Graphics;\n//   move?: {x: number, y: number};\n// }\n// export const renderShapePartialShape = ({ layer, graphic, move }: RenderShapePartialShapeOptions): Promise<PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     renderShapePathShape({\n//       graphic: graphic,\n//       layer: layer,\n//       move: move\n//     })\n//     .then(() => {\n//       graphic.beginHole();\n//       return renderShapePartialHoles({\n//         layer: layer,\n//         graphic: graphic\n//       });\n//     })\n//     .then(() => {\n//       graphic.endHole();\n//       resolve(graphic);\n//     });\n//   });\n// }\n// interface DrawLayerShapeOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial | srm.ShapePartialHole | srm.Shape | srm.Group | srm.Text;\n//   graphic: PIXI.Graphics;\n//   move?: {x: number, y: number};\n// }\n// export const drawLayerShape = ({ layer, graphic, move }: DrawLayerShapeOptions): Promise<PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     switch(layer.type) {\n//       case 'ShapePath':\n//       case 'ShapePartialHole':\n//         renderShapePathShape({\n//           graphic: graphic,\n//           layer: layer as srm.ShapePath | srm.ShapePartialHole,\n//           move: move\n//         })\n//         .then(() => {\n//           resolve(graphic);\n//         });\n//         break;\n//       case 'ShapePartial':\n//         renderShapePartialShape({\n//           graphic: graphic,\n//           layer: layer as srm.ShapePartial,\n//           move: move\n//         })\n//         .then(() => {\n//           resolve(graphic);\n//         });\n//         break;\n//       case 'Image':\n//       case 'Shape':\n//       case 'Group':\n//       case 'Text':\n//         graphic.drawRect(0, 0, layer.frame.width, layer.frame.height);\n//         resolve(graphic);\n//         break;\n//     }\n//   });\n// }\n// interface RenderBorderColorOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   border: srm.Border;\n//   borderIndex: number;\n//   container: PIXI.Container;\n// }\n// export const renderBorderColor = ({ layer, border, borderIndex, container }: RenderBorderColorOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const { color, thickness, position } = border;\n//     const borderColor = new PIXI.Graphics();\n//     borderColor.name = `border-${borderIndex}`;\n//     const borderStyles = colorToFill(color);\n//     const translatedAlignment = borderPositionToAlignment(position);\n//     // hole borders wont render unless there is a fill\n//     borderColor.beginFill(0x000000, 0.001);\n//     borderColor.lineStyle(thickness, borderStyles.color, 1, translatedAlignment);\n//     drawLayerShape({\n//       graphic: borderColor,\n//       layer: layer as srm.ShapePartial\n//     })\n//     .then(() => {\n//       borderColor.endFill();\n//       return renderOpacity({\n//         opacity: borderStyles.alpha,\n//         container: borderColor\n//       });\n//     })\n//     .then(() => {\n//       container.addChild(borderColor);\n//     })\n//     .finally(() => {\n//       resolve(container);\n//     });\n//   });\n// };\n// interface RenderBorderGradientOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   border: srm.Border;\n//   borderIndex: number;\n//   resources: PIXI.LoaderResource[];\n//   container: PIXI.Container;\n// }\n// export const renderBorderGradient = ({ layer, border, borderIndex, resources, container }: RenderBorderGradientOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const borderGradient = new PIXI.Graphics();\n//     borderGradient.name = `border-${borderIndex}`;\n//     let gradientTexture;\n//     if (layer.type === 'ShapePartial') {\n//       const baseTexture = new PIXI.BaseTexture(resources[`[border-${borderIndex}]${(layer as srm.ShapePartial).shape.id}` as any].url);\n//       const frame = new PIXI.Rectangle(layer.frame.x - layer.frame.width, layer.frame.y - layer.frame.height, layer.frame.width, layer.frame.height);\n//       gradientTexture = new PIXI.Texture(baseTexture, frame);\n//     } else {\n//       gradientTexture = PIXI.Texture.from(resources[`[border-${borderIndex}]${layer.id}` as any].url);\n//     }\n//     // hole borders wont render unless there is a fill\n//     borderGradient.beginFill(0x000000, 0.001);\n//     borderGradient.lineTextureStyle({\n//       width: border.thickness,\n//       texture: gradientTexture,\n//       alignment: borderPositionToAlignment(border.position)\n//     });\n//     drawLayerShape({\n//       graphic: borderGradient,\n//       layer: layer as srm.ShapePath | srm.Image\n//     })\n//     .then((borderGradient) => {\n//       borderGradient.endFill();\n//       container.addChild(borderGradient);\n//     })\n//     .finally(() => {\n//       resolve(borderGradient);\n//     });\n//   });\n// };\n// interface RenderBorderOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   border: srm.Border;\n//   borderIndex: number;\n//   resources: PIXI.LoaderResource[];\n//   container: PIXI.Container;\n// }\n// const renderBorder = ({ layer, border, borderIndex, resources, container }: RenderBorderOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     switch(border.fillType) {\n//       case 'Color':\n//         renderBorderColor({\n//           layer: layer as srm.ShapePath | srm.Image | srm.ShapePartial,\n//           border: border,\n//           borderIndex: borderIndex,\n//           container: container\n//         })\n//         .then((container) => {\n//           resolve(container);\n//         });\n//         break;\n//       case 'Gradient':\n//         renderBorderGradient({\n//           layer: layer as srm.ShapePath | srm.Image | srm.ShapePartial,\n//           border: border,\n//           borderIndex: borderIndex,\n//           resources: resources,\n//           container: container\n//         })\n//         .then((container) => {\n//           resolve(container);\n//         });\n//         break;\n//     }\n//   });\n// }\n// interface RenderBordersOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   borders: srm.Border[];\n//   resources: PIXI.LoaderResource[];\n//   container: PIXI.Container;\n// }\n// export const renderBorders = ({ layer, borders, resources, container }: RenderBordersOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     if (borders.length > 0 && borders.some(border => border.enabled)) {\n//       let bordersContainer = new PIXI.Container();\n//       bordersContainer.name = 'borders';\n//       let promises: Promise<PIXI.Container>[] = [];\n//       borders.forEach((border: srm.Border, borderIndex: number) => {\n//         if (border.enabled) {\n//           promises.push(renderBorder({\n//             layer: layer,\n//             border: border,\n//             borderIndex: borderIndex,\n//             resources: resources,\n//             container: bordersContainer\n//           }));\n//         }\n//       });\n//       Promise.all(promises).then(() => {\n//         container.addChild(bordersContainer);\n//         resolve(container);\n//       });\n//     } else {\n//       resolve(container);\n//     }\n//   });\n// };\n// interface RenderFillColorOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial | srm.Text;\n//   fill: srm.Fill;\n//   fillIndex: number;\n//   container: PIXI.Container;\n// }\n// export const renderFillColor = ({ layer, fill, fillIndex, container }: RenderFillColorOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const fillColor = new PIXI.Graphics();\n//     fillColor.name = `fill-${fillIndex}`;\n//     const fillStyles = colorToFill(fill.color);\n//     fillColor.beginFill(fillStyles.color, fillStyles.alpha);\n//     drawLayerShape({\n//       layer: layer,\n//       graphic: fillColor\n//     })\n//     .then((fillColor) => {\n//       fillColor.endFill();\n//       container.addChild(fillColor);\n//       resolve(container);\n//     });\n//   });\n// };\n// interface RenderFillImageOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial | srm.Text;\n//   fillIndex: number;\n//   resources: PIXI.LoaderResource[];\n//   container: PIXI.Container;\n// }\n// export const renderFillImage = ({ layer, fillIndex, resources, container }: RenderFillImageOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const fillImage = new PIXI.Graphics();\n//     fillImage.name = `fill-${fillIndex}`;\n//     let fillTexture;\n//     if (layer.type === 'ShapePartial') {\n//       const baseTexture = new PIXI.BaseTexture(resources[`[fill-${fillIndex}]${(layer as srm.ShapePartial).shape.id}` as any].url);\n//       const frame = new PIXI.Rectangle(layer.frame.x, layer.frame.y, layer.frame.width, layer.frame.height);\n//       fillTexture = new PIXI.Texture(baseTexture, frame);\n//     } else {\n//       fillTexture = PIXI.Texture.from(resources[`[fill-${fillIndex}]${layer.id}` as any].url);\n//     }\n//     fillImage.beginTextureFill({texture: fillTexture});\n//     drawLayerShape({\n//       layer: layer,\n//       graphic: fillImage\n//     })\n//     .then((fillImage) => {\n//       fillImage.endFill();\n//       container.addChild(fillImage);\n//       resolve(container);\n//     });\n//   });\n// };\n// interface RenderFillOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial | srm.Text;\n//   fill: srm.Fill;\n//   fillIndex: number;\n//   resources: PIXI.LoaderResource[];\n//   container: PIXI.Container;\n// }\n// const renderFill = ({ layer, fill, fillIndex, resources, container }: RenderFillOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     switch(fill.fillType) {\n//       case 'Color':\n//         renderFillColor({\n//           layer: layer,\n//           fill: fill,\n//           fillIndex: fillIndex,\n//           container: container\n//         })\n//         .then(() => {\n//           resolve(container);\n//         });\n//         break;\n//       case 'Pattern':\n//       case 'Gradient':\n//         renderFillImage({\n//           layer: layer,\n//           fillIndex: fillIndex,\n//           resources: resources,\n//           container: container\n//         })\n//         .then(() => {\n//           resolve(container);\n//         });\n//         break;\n//     }\n//   });\n// }\n// interface RenderFillsOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial | srm.Text;\n//   fills: srm.Fill[];\n//   resources: PIXI.LoaderResource[];\n//   container: PIXI.Container;\n// }\n// export const renderFills = ({ layer, fills, resources, container }: RenderFillsOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     if (fills.length > 0 && fills.some(fill => fill.enabled)) {\n//       let fillsContainer = new PIXI.Container();\n//       fillsContainer.name = 'fills';\n//       let promises: Promise<PIXI.Container>[] = [];\n//       fills.forEach((fill: srm.Fill, fillIndex: number) => {\n//         if (fill.enabled) {\n//           promises.push(renderFill({\n//             layer: layer,\n//             fill: fill,\n//             fillIndex: fillIndex,\n//             resources: resources,\n//             container: fillsContainer\n//           }));\n//         }\n//       });\n//       Promise.all(promises).then(() => {\n//         container.addChild(fillsContainer);\n//         resolve(container);\n//       });\n//     } else {\n//       resolve(container);\n//     }\n//   });\n// };\n// interface RenderTransformsOptions {\n//   layer: srm.ShapePath | srm.Shape | srm.Image | srm.Group;\n//   transform: srm.Transform;\n//   container: PIXI.Container;\n// }\n// export const renderTransforms = ({ layer, transform, container }: RenderTransformsOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const hFlip = transform.flippedHorizontally ? -1 : 1;\n//     const vFlip = transform.flippedVertically ? -1 : 1;\n//     container.scale.x = hFlip;\n//     container.scale.y = vFlip;\n//     container.rotation = (transform.rotation * (Math.PI/180)) * hFlip * vFlip;\n//     resolve(container);\n//   });\n// };\n// interface SetBaseLayerContainerOptions {\n//   layer: srm.ShapePath | srm.Shape | srm.Image | srm.Group | srm.Text;\n//   container: PIXI.Container;\n// }\n// export const setBaseLayerContainer = ({ layer, container }: SetBaseLayerContainerOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const { frame } = layer;\n//     container.width = frame.width;\n//     container.height = frame.height;\n//     container.position.x = frame.x + frame.width / 2;\n//     container.position.y = frame.y + frame.height / 2;\n//     container.pivot.x = frame.width / 2;\n//     container.pivot.y = frame.height / 2;\n//     resolve(container);\n//   });\n// };\n// interface RenderBlurOptions {\n//   layer: srm.ShapePath | srm.Shape | srm.Image | srm.Group;\n//   blur: srm.Blur;\n//   container: PIXI.Container\n// }\n// export const renderBlur = ({ layer, blur, container }: RenderBlurOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     if (blur.enabled) {\n//       switch(blur.blurType) {\n//         case 'Gaussian':\n//           const gaussianBlur =  new PIXI.filters.BlurFilter();\n//           gaussianBlur.blur = blur.radius;\n//           gaussianBlur.quality = 10;\n//           container.filters = [gaussianBlur];\n//           break;\n//         case 'Zoom':\n//           const zoomBlur =  new ZoomBlurFilter();\n//           zoomBlur.strength = blur.radius / 100;\n//           zoomBlur.center = [blur.center.x * layer.frame.width, blur.center.y * layer.frame.height];\n//           container.filters = [zoomBlur];\n//           break;\n//         default:\n//           break;\n//       }\n//     }\n//     resolve(container);\n//   });\n// };\n// interface RenderGroupsShadowsOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   groupShadows?: srm.GroupShadows[] | undefined;\n//   container: PIXI.Container;\n// }\n// export const renderGroupsShadows = ({ layer, groupShadows, container }: RenderGroupsShadowsOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     if (groupShadows) {\n//       const groupsShadowsContainer = new PIXI.Container();\n//       groupsShadowsContainer.name = 'group-shadows';\n//       const promises: Promise<PIXI.Container>[] = [];\n//       groupShadows.forEach((groupShadow) => {\n//         promises.push(renderGroupShadows({\n//           layer: layer,\n//           groupShadows: groupShadow,\n//           container: groupsShadowsContainer\n//         }));\n//       })\n//       Promise.all(promises).then(() => {\n//         container.addChild(groupsShadowsContainer);\n//         resolve(container);\n//       });\n//     } else {\n//       resolve(container);\n//     }\n//   });\n// };\n// interface RenderGroupShadowsOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   groupShadows: srm.GroupShadows;\n//   container: PIXI.Container;\n// }\n// export const renderGroupShadows = ({ layer, groupShadows, container }: RenderGroupShadowsOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const promises: Promise<PIXI.Container>[] = [];\n//     const groupShadowsContainer = new PIXI.Container();\n//     groupShadowsContainer.name = groupShadows.id;\n//     groupShadows.shadows.forEach((shadow: srm.Shadow, shadowIndex: number) => {\n//       if (shadow.enabled) {\n//         promises.push(renderShadow({\n//           layer: layer,\n//           shadow: shadow,\n//           shadowIndex: shadowIndex,\n//           container: groupShadowsContainer\n//         }));\n//       }\n//     });\n//     Promise.all(promises).then(() => {\n//       container.addChild(groupShadowsContainer);\n//       resolve(container);\n//     });\n//   });\n// };\n// interface RenderShadowsOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   shadows: srm.Shadow[];\n//   container: PIXI.Container;\n// }\n// export const renderShadows = ({ layer, shadows, container }: RenderShadowsOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     if (shadows.length > 0 && shadows.some(shadow => shadow.enabled)) {\n//       let shadowsContainer = new PIXI.Container();\n//       shadowsContainer.name = 'shadows';\n//       const promises: Promise<PIXI.Container>[] = [];\n//       shadows.forEach((shadow: srm.Shadow, shadowIndex: number) => {\n//         if (shadow.enabled) {\n//           promises.push(renderShadow({\n//             layer: layer,\n//             shadow: shadow,\n//             shadowIndex: shadowIndex,\n//             container: shadowsContainer\n//           }));\n//         }\n//       });\n//       Promise.all(promises).then(() => {\n//         container.addChild(shadowsContainer);\n//         resolve(container);\n//       });\n//     } else {\n//       resolve(container);\n//     }\n//   });\n// };\n// interface RenderShadowOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   shadow: srm.Shadow;\n//   shadowIndex: number;\n//   container: PIXI.Container;\n// }\n// export const renderShadow = ({ layer, shadow, shadowIndex, container }: RenderShadowOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const shadowStyles = colorToFill(shadow.color);\n//     const shadowGraphic = new PIXI.Graphics();\n//     shadowGraphic.name = `shadow-${shadowIndex}`;\n//     shadowGraphic.position.x = shadow.x;\n//     shadowGraphic.position.y = shadow.y;\n//     renderOpacity({\n//       opacity: shadowStyles.alpha,\n//       container: shadowGraphic\n//     })\n//     .then(() => {\n//       return renderShadowBase({\n//         layer: layer,\n//         shadowStyles: shadowStyles,\n//         shadowSpread: shadow.spread,\n//         shadowGraphic: shadowGraphic\n//       });\n//     })\n//     .then(() => {\n//       return renderShadowBlur({\n//         shadowBlur: shadow.blur,\n//         shadowGraphic: shadowGraphic\n//       });\n//     })\n//     .then(() => {\n//       container.addChild(shadowGraphic);\n//     })\n//     .finally(() => {\n//       resolve(container);\n//     });\n//   });\n// };\n// interface RenderShadowBaseOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   shadowStyles: {color: number, alpha: number};\n//   shadowSpread: number;\n//   shadowGraphic: PIXI.Graphics;\n// }\n// export const renderShadowBase = ({ layer, shadowStyles, shadowSpread, shadowGraphic }: RenderShadowBaseOptions): Promise<PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     const layerFills = layer.type === 'ShapePartial' ? (layer as srm.ShapePartial).shape.style.fills : layer.style.fills;\n//     const layerBorders = layer.type === 'ShapePartial' ? (layer as srm.ShapePartial).shape.style.borders : layer.style.borders\n//     const activeFills = layerFills.some(fill => fill.enabled);\n//     const activeBorders = layerBorders.some(border => border.enabled);\n//     const borderSize = getCompiledBorderThickness(layerBorders);\n//     if (activeFills || !activeBorders || layer.type === 'Image') {\n//       shadowGraphic.beginFill(shadowStyles.color, 1);\n//       shadowGraphic.lineStyle(borderSize / 2 + shadowSpread, shadowStyles.color, 1, 1);\n//     } else {\n//       shadowGraphic.beginFill(shadowStyles.color, 0.001);\n//       shadowGraphic.lineStyle(borderSize + shadowSpread, shadowStyles.color);\n//     }\n//     drawLayerShape({\n//       layer: layer,\n//       graphic: shadowGraphic\n//     })\n//     .then(() => {\n//       shadowGraphic.endFill();\n//     })\n//     .finally(() => {\n//       resolve(shadowGraphic);\n//     });\n//   });\n// };\n// interface RenderShadowBlurOptions {\n//   shadowBlur: number;\n//   shadowGraphic: PIXI.Graphics;\n// }\n// export const renderShadowBlur = ({ shadowBlur, shadowGraphic }: RenderShadowBlurOptions): Promise<PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     if (shadowBlur > 0) {\n//       const blurFilter =  new PIXI.filters.BlurFilter();\n//       blurFilter.blur = shadowBlur;\n//       blurFilter.quality = 10;\n//       blurFilter.autoFit = true;\n//       shadowGraphic.filters = shadowGraphic.filters ? [...shadowGraphic.filters, blurFilter] : [blurFilter];\n//     }\n//     resolve(shadowGraphic);\n//   });\n// };\n// interface RenderInnerShadowsOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   innerShadows: srm.Shadow[];\n//   container: PIXI.Container;\n// }\n// export const renderInnerShadows = ({ layer, innerShadows, container }: RenderInnerShadowsOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     if (innerShadows.length > 0 && innerShadows.some(innerShadow => innerShadow.enabled)) {\n//       const innerShadowsContainer = new PIXI.Container();\n//       innerShadowsContainer.name = 'inner-shadows';\n//       const maskedContainer = new PIXI.Container();\n//       maskedContainer.name = 'masked-inner-shadows';\n//       const maskGraphic = new PIXI.Graphics();\n//       maskGraphic.name = 'inner-shadows-mask';\n//       renderMaskedInnerShadows({\n//         layer: layer,\n//         innerShadows: innerShadows,\n//         maskedContainer: maskedContainer,\n//         container: innerShadowsContainer\n//       })\n//       .then(() => {\n//         return renderInnerShadowsMask({\n//           layer: layer,\n//           maskGraphic: maskGraphic,\n//           container: innerShadowsContainer\n//         });\n//       })\n//       .then(() => {\n//         maskedContainer.mask = maskGraphic;\n//         container.addChild(innerShadowsContainer);\n//       })\n//       .finally(() => {\n//         resolve(container);\n//       });\n//     } else {\n//       resolve(container);\n//     }\n//   });\n// };\n// interface RenderMaskedInnerShadowsOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   innerShadows: srm.Shadow[];\n//   maskedContainer: PIXI.Container;\n//   container: PIXI.Container;\n// }\n// export const renderMaskedInnerShadows = ({ layer, innerShadows, maskedContainer, container }: RenderMaskedInnerShadowsOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const promises: Promise<PIXI.Container>[] = [];\n//     innerShadows.forEach((innerShadow: srm.Shadow, innerShadowIndex: number) => {\n//       if (innerShadow.enabled) {\n//         promises.push(renderInnerShadow({\n//           layer: layer,\n//           innerShadow: innerShadow,\n//           innerShadowIndex: innerShadowIndex,\n//           container: maskedContainer\n//         }));\n//       }\n//     });\n//     Promise.all(promises).then(() => {\n//       container.addChild(maskedContainer);\n//       resolve(container);\n//     });\n//   });\n// };\n// interface RenderInnerShadowsMaskOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   maskGraphic: PIXI.Graphics;\n//   container: PIXI.Container;\n// }\n// export const renderInnerShadowsMask = ({ layer, maskGraphic, container }: RenderInnerShadowsMaskOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     maskGraphic.beginFill(0x000000);\n//     drawLayerShape({\n//       layer: layer,\n//       graphic: maskGraphic\n//     })\n//     .then(() => {\n//       maskGraphic.endFill();\n//       container.addChild(maskGraphic);\n//     })\n//     .finally(() => {\n//       resolve(container);\n//     });\n//   });\n// };\n// interface RenderInnerShadowOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   innerShadow: srm.Shadow;\n//   innerShadowIndex: number;\n//   container: PIXI.Container;\n// }\n// export const renderInnerShadow = ({ layer, innerShadow, innerShadowIndex, container }: RenderInnerShadowOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     const innerShadowStyles = colorToFill(innerShadow.color);\n//     const innerShadowGraphic = new PIXI.Graphics();\n//     innerShadowGraphic.name = `inner-shadow-${innerShadowIndex}`;\n//     innerShadowGraphic.position.x = innerShadow.x;\n//     innerShadowGraphic.position.y = innerShadow.y;\n//     renderOpacity({\n//       opacity: innerShadowStyles.alpha,\n//       container: innerShadowGraphic\n//     })\n//     .then(() => {\n//       return renderInnerShadowBase({\n//         layer: layer,\n//         innerShadow: innerShadow,\n//         innerShadowGraphic: innerShadowGraphic,\n//         innerShadowStyles: innerShadowStyles\n//       });\n//     })\n//     .then(() => {\n//       return renderInnerShadowSpread({\n//         layer: layer,\n//         innerShadow: innerShadow,\n//         innerShadowGraphic: innerShadowGraphic,\n//         innerShadowStyles: innerShadowStyles\n//       });\n//     })\n//     .then(() => {\n//       return renderInnerShadowHoles({\n//         layer: layer,\n//         innerShadow: innerShadow,\n//         innerShadowGraphic: innerShadowGraphic,\n//         innerShadowStyles: innerShadowStyles\n//       });\n//     })\n//     .then(() => {\n//       return renderShadowBlur({\n//         shadowBlur: innerShadow.blur,\n//         shadowGraphic: innerShadowGraphic\n//       });\n//     })\n//     .then(() => {\n//       container.addChild(innerShadowGraphic);\n//     })\n//     .finally(() => {\n//       resolve(container);\n//     });\n//   });\n// };\n// interface RenderInnerShadowBaseOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   innerShadow: srm.Shadow;\n//   innerShadowGraphic: PIXI.Graphics;\n//   innerShadowStyles: {color: number, alpha: number};\n// }\n// export const renderInnerShadowBase = ({ layer, innerShadow, innerShadowStyles, innerShadowGraphic }: RenderInnerShadowBaseOptions): Promise<PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     const maxSize = innerShadow.y + innerShadow.x + 3;\n//     innerShadowGraphic.lineStyle(maxSize, innerShadowStyles.color, 1, 1);\n//     drawLayerShape({\n//       layer: layer,\n//       graphic: innerShadowGraphic\n//     })\n//     .finally(() => {\n//       resolve(innerShadowGraphic);\n//     });\n//   });\n// };\n// interface RenderInnerShadowSpreadOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   innerShadow: srm.Shadow;\n//   innerShadowGraphic: PIXI.Graphics;\n//   innerShadowStyles: {color: number, alpha: number};\n// }\n// export const renderInnerShadowSpread = ({ layer, innerShadow, innerShadowStyles, innerShadowGraphic }: RenderInnerShadowSpreadOptions): Promise<PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     if (innerShadow.spread > 0) {\n//       innerShadowGraphic.lineStyle(innerShadow.spread, innerShadowStyles.color, 1, 0);\n//       drawLayerShape({\n//         layer: layer,\n//         graphic: innerShadowGraphic\n//       })\n//       .finally(() => {\n//         resolve(innerShadowGraphic);\n//       });\n//     } else {\n//       resolve(innerShadowGraphic);\n//     }\n//   });\n// };\n// interface RenderInnerShadowHolesOptions {\n//   layer: srm.ShapePath | srm.Image | srm.ShapePartial;\n//   innerShadow: srm.Shadow;\n//   innerShadowGraphic: PIXI.Graphics;\n//   innerShadowStyles: {color: number, alpha: number};\n// }\n// export const renderInnerShadowHoles = ({ layer, innerShadow, innerShadowStyles, innerShadowGraphic }: RenderInnerShadowHolesOptions): Promise<PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     if (layer.type === 'ShapePartial' && (layer as srm.ShapePartial).holes.length > 0) {\n//       const promises: Promise<PIXI.Graphics>[] = [];\n//       innerShadowGraphic.beginFill(innerShadowStyles.color);\n//       // pixi is bugged, this should be linestyle alignment 1\n//       innerShadowGraphic.lineStyle(innerShadow.spread, innerShadowStyles.color, 1, 0);\n//       (layer as srm.ShapePartial).holes.forEach((hole: srm.ShapePartialHole) => {\n//         promises.push(drawLayerShape({\n//           layer: hole,\n//           graphic: innerShadowGraphic,\n//           move: {x: hole.frame.x - hole.shapePath.frame.x, y: hole.frame.y - hole.shapePath.frame.y}\n//         }));\n//       });\n//       Promise.all(promises).then(() => {\n//         innerShadowGraphic.endFill();\n//         resolve(innerShadowGraphic);\n//       });\n//     } else {\n//       resolve(innerShadowGraphic);\n//     }\n//   });\n// };\n// interface RenderOpacityOptions {\n//   opacity: number;\n//   container: PIXI.Container | PIXI.Graphics;\n// }\n// export const renderOpacity = ({ opacity, container }: RenderOpacityOptions): Promise<PIXI.Container | PIXI.Graphics> => {\n//   return new Promise((resolve, reject) => {\n//     if (opacity < 1) {\n//       const alphaFilter = new PIXI.filters.AlphaFilter(opacity);\n//       container.filters = container.filters ? [...container.filters, alphaFilter] : [alphaFilter];\n//     }\n//     resolve(container);\n//   });\n// };\n// interface RenderBlendModeOptions {\n//   blendMode: srm.BlendingMode;\n//   container: PIXI.Container;\n// }\n// export const renderBlendMode = ({ blendMode, container }: RenderBlendModeOptions): Promise<PIXI.Container> => {\n//   return new Promise((resolve, reject) => {\n//     if (blendMode === 'Multiply') {\n//       // webgl renderer only supports multiply currently\n//       const colorMatrix = new PIXI.filters.ColorMatrixFilter();\n//       colorMatrix.blendMode = PIXI.BLEND_MODES.MULTIPLY;\n//       container.filters = container.filters ? [...container.filters, colorMatrix] : [colorMatrix];\n//     }\n//     resolve(container);\n//   });\n// };\n"],"sourceRoot":""}