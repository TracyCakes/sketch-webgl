{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./resources/store/artboard.js"],"names":["processMask","layer","sketch","Promise","resolve","reject","sketchObject","hasClippingMask","maskIndex","index","maskParent","parent","setHasClippingMask","maskGroup","Group","name","frame","layers","duplicate","splice","forEach","maskedLayer","x","y","push","isPathClockwise","points","end","length","sum","point","i","n","flattenShapePath","isClockwise","reversePath","transform","rotation","flippedHorizontally","flippedVertically","svgPath","getSVGPath","flatPath","ShapePath","fromSVGPath","remove","processShapePathBorderOptions","style","borderOptions","dashPattern","startArrowhead","endArrowhead","layersByConvertingToOutlines","outlines","simplify","processShapePath","type","then","layerS1","layerS2","processShapeBase","canFlatten","flatten","ungroup","ungrouped","processShape","processRelevant","processHidden","isHidden","hidden","processSymbol","detach","recursively","processText","text","trim","layerIndex","processLayer","page","layerS3","layerS4","layerS5","layerS6","layerS7","processLayers","promises","all","getArtboard","artboard"],"mappings":"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","file":"resources_store_artboard.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./resources/store/artboard.js\");\n","const processMask = ({ layer, sketch }) => {\n    return new Promise((resolve, reject) => {\n        if (layer && layer.sketchObject.hasClippingMask()) {\n            const maskIndex = layer.index;\n            const maskParent = layer.parent;\n            layer.sketchObject.setHasClippingMask(false);\n            // create new group to mimic mask behavior\n            const maskGroup = new sketch.Group({\n                name: 'srm.mask',\n                frame: layer.frame,\n                layers: [layer.duplicate()]\n            });\n            // splice in mask group, splice out old mask\n            maskParent.layers.splice(maskIndex, 1, maskGroup);\n            // loop through mask parent layers,\n            // any layer with an index higher than the mask will be masked\n            // push masked layers to maskGroup\n            maskGroup.parent.layers.forEach((maskedLayer, index) => {\n                if (index > maskIndex) {\n                    maskedLayer.frame.x = maskedLayer.frame.x - maskGroup.frame.x;\n                    maskedLayer.frame.y = maskedLayer.frame.y - maskGroup.frame.y;\n                    maskGroup.layers.push(maskedLayer);\n                }\n            });\n            resolve(maskGroup);\n        }\n        else {\n            resolve(layer);\n        }\n    });\n};\nconst isPathClockwise = (points) => {\n    let end = points.length - 1;\n    let sum = points[end].point.x * points[0].point.y - points[0].point.x * points[end].point.y;\n    for (let i = 0; i < end; i++) {\n        const n = i + 1;\n        sum += points[i].point.x * points[n].point.y - points[n].point.x * points[i].point.y;\n    }\n    return sum > 0;\n};\nconst flattenShapePath = ({ layer, sketch }) => {\n    return new Promise((resolve, reject) => {\n        // due to the way PIXI draws lines\n        // the path must be clockwise to render correctly\n        const isClockwise = isPathClockwise(layer.points);\n        if (!isClockwise) {\n            layer.sketchObject.reversePath();\n        }\n        const duplicate = layer.duplicate();\n        duplicate.transform.rotation = 0;\n        duplicate.transform.flippedHorizontally = false;\n        duplicate.transform.flippedVertically = false;\n        const svgPath = duplicate.getSVGPath();\n        const flatPath = sketch.ShapePath.fromSVGPath(svgPath);\n        layer.points = flatPath.points;\n        duplicate.remove();\n        resolve(layer);\n    });\n};\nconst processShapePathBorderOptions = ({ layer }) => {\n    return new Promise((resolve, reject) => {\n        const { parent, index, style } = layer;\n        const { borderOptions } = style;\n        if (borderOptions.dashPattern.length > 0 || borderOptions.startArrowhead !== 'None' || borderOptions.endArrowhead !== 'None') {\n            layer.sketchObject.layersByConvertingToOutlines();\n            const outlines = parent.layers[index];\n            outlines.name = `[srm.with-border-options]${layer.name}`;\n            outlines.sketchObject.simplify();\n            resolve(outlines);\n        }\n        else {\n            resolve(layer);\n        }\n    });\n};\nconst processShapePath = ({ layer, sketch }) => {\n    return new Promise((resolve, reject) => {\n        if (layer && layer.type === 'ShapePath') {\n            flattenShapePath({\n                layer: layer,\n                sketch: sketch\n            })\n                .then((layerS1) => {\n                return processShapePathBorderOptions({\n                    layer: layerS1\n                });\n            })\n                .then((layerS2) => {\n                resolve(layerS2);\n            });\n        }\n        else {\n            resolve(layer);\n        }\n    });\n};\nconst processShapeBase = ({ layer }) => {\n    return new Promise((resolve, reject) => {\n        const { style, parent, index } = layer;\n        if (layer.sketchObject.canFlatten()) {\n            layer.sketchObject.flatten();\n            resolve(parent.layers[index]);\n        }\n        else {\n            if (layer.layers.length === 1) {\n                layer.sketchObject.ungroup();\n                const ungrouped = parent.layers[index];\n                ungrouped.style = style;\n                resolve(ungrouped);\n            }\n            else {\n                resolve(layer);\n            }\n        }\n    });\n};\nconst processShape = ({ layer, sketch }) => {\n    return new Promise((resolve, reject) => {\n        if (layer && layer.type === 'Shape') {\n            processShapeBase({\n                layer: layer\n            })\n                // .then((layerS1) => {\n                //   if (layerS1.type === 'Shape') {\n                //     return processShapeLayers({\n                //       layer: layerS1 as srm.Shape,\n                //       sketch: sketch\n                //     });\n                //   } else {\n                //     resolve(layerS1);\n                //   }\n                // })\n                .then((layerS2) => {\n                resolve(layerS2);\n            });\n        }\n        else {\n            resolve(layer);\n        }\n    });\n};\nconst processRelevant = ({ layer }) => {\n    return new Promise((resolve, reject) => {\n        switch (layer.type) {\n            case 'Group':\n            case 'Shape':\n            case 'Image':\n            case 'ShapePath':\n            case 'Text':\n            case 'SymbolInstance':\n                resolve(layer);\n                break;\n            case 'HotSpot':\n            case 'Slice':\n                layer.remove();\n                resolve(null);\n                break;\n        }\n    });\n};\nconst processHidden = ({ layer }) => {\n    return new Promise((resolve, reject) => {\n        const isHidden = layer && layer.hidden;\n        if (isHidden) {\n            layer.remove();\n            resolve(null);\n        }\n        else {\n            resolve(layer);\n        }\n    });\n};\nconst processSymbol = ({ layer }) => {\n    return new Promise((resolve, reject) => {\n        if (layer && layer.type === 'SymbolInstance') {\n            resolve(layer.detach({\n                recursively: true\n            }));\n        }\n        else {\n            resolve(layer);\n        }\n    });\n};\nconst processText = ({ layer, sketch }) => {\n    return new Promise((resolve, reject) => {\n        if (layer && layer.type === 'Text') {\n            if (layer.text.trim().length === 0) {\n                layer.remove();\n                resolve(null);\n            }\n            else {\n                const layerIndex = layer.index;\n                const parent = layer.parent;\n                layer.sketchObject.layersByConvertingToOutlines();\n                const outlines = parent.layers[layerIndex];\n                outlines.name = `[srm.text]${layer.name}`;\n                // because sketch is bugged\n                outlines.sketchObject.simplify();\n                // because pixi is bugged\n                outlines.sketchObject.reversePath();\n                resolve(outlines);\n            }\n        }\n        else {\n            resolve(layer);\n        }\n    });\n};\nconst processLayer = ({ layer, sketch, page }) => {\n    return new Promise((resolve, reject) => {\n        processRelevant({\n            layer: layer\n        })\n            .then((layerS1) => {\n            return processHidden({\n                layer: layerS1\n            });\n        })\n            .then((layerS2) => {\n            return processSymbol({\n                layer: layerS2\n            });\n        })\n            .then((layerS3) => {\n            return processShape({\n                layer: layerS3,\n                sketch: sketch\n            });\n        })\n            .then((layerS4) => {\n            return processShapePath({\n                layer: layerS4,\n                sketch: sketch\n            });\n        })\n            .then((layerS5) => {\n            return processMask({\n                layer: layerS5,\n                sketch: sketch\n            });\n        })\n            .then((layerS6) => {\n            return processText({\n                layer: layerS6,\n                sketch: sketch\n            });\n        })\n            .then((layerS7) => {\n            if (layerS7 && layerS7.type === 'Group') {\n                processLayers({\n                    layers: layerS7.layers,\n                    sketch: sketch,\n                    page: page\n                })\n                    .then(() => {\n                    resolve();\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    });\n};\nconst processLayers = ({ layers, sketch, page }) => {\n    const promises = [];\n    layers.forEach((layer) => {\n        promises.push(processLayer({\n            layer: layer,\n            sketch: sketch,\n            page: page\n        }));\n    });\n    return Promise.all(promises);\n};\nconst getArtboard = ({ artboard, sketch, page }) => {\n    return new Promise((resolve, reject) => {\n        processLayers({\n            layers: artboard.layers,\n            sketch: sketch,\n            page: page\n        })\n            .then(() => {\n            resolve();\n        });\n    });\n};\nexport default getArtboard;\n"],"sourceRoot":""}